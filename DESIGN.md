# Design Decisions

## Technology Stack

### Runtime: Node.js

Node.js was chosen because:
- **Zero install friction on macOS** — Node.js is available via Homebrew (`brew install node`) or the official installer, and is already present on many developer machines.
- **Single language** — TypeScript is used on both the server and the browser, so there is no context-switch between languages.
- **Large ecosystem** — npm provides a vast library of packages if the project needs to grow.
- **Production-ready** — Node.js powers many high-traffic websites, so the same code that runs locally can be deployed to a live server without changes.

### Language: TypeScript

TypeScript was chosen over plain JavaScript because:
- **Type safety** — interfaces such as `Task` catch shape mismatches between the database layer, the API, and the browser at compile time rather than at runtime.
- **Better readability** — explicit types serve as inline documentation for function signatures and data structures.
- **Improved tooling** — editors provide accurate autocompletion, rename-refactoring, and go-to-definition across the whole project.
- **Zero-overhead migration** — `ts-node` runs the server directly from source; `tsc` compiles the browser bundle to `public/app.js`; `ts-jest` handles tests. No additional build pipeline is required.

### Web Framework: Express

Express was chosen because:
- **Minimal and un-opinionated** — it adds only a thin layer on top of Node's built-in `http` module, making it easy to understand and extend.
- **Industry standard** — widely documented, with a large community and many deployment guides.
- **Serves static files** — `express.static` lets the same server deliver both the API and the HTML/CSS/JS frontend with no extra tooling.

### Frontend: Plain HTML + CSS + TypeScript

No front-end framework (React, Vue, etc.) was chosen for the initial scaffold because:
- **Minimal build step** — `tsc -p tsconfig.client.json` compiles `public/app.ts` to `public/app.js`; no bundler is needed.
- **Simpler onboarding** — anyone can read `public/app.ts` and understand it immediately.
- **Easy to upgrade** — if a framework is needed later, the existing API and file layout remain unchanged; only the `public/` directory would be replaced.

### Data Storage: SQLite

Tasks are persisted in a SQLite database using `better-sqlite3`. The database file path is controlled by the `DB_PATH` environment variable (defaults to `./tasks.db`).

```bash
bash run_local.sh                          # uses ./tasks.db
DB_PATH=/path/to/myapp.db bash run_local.sh  # custom path
```

SQLite was chosen because:
- **Zero-config** — no separate database process to install or manage.
- **Persistent** — tasks survive server restarts.
- **Portable** — the entire database is a single file that can be copied or deleted easily.

For tests, `DB_PATH=:memory:` uses SQLite's built-in in-memory mode

## Project Structure

```
cupcake/
├── server.ts        # Express server + REST API (TypeScript source)
├── db.ts            # SQLite data-access layer (TypeScript source)
├── package.json     # Dependencies and npm scripts
├── tsconfig.json    # TypeScript config for server + tests
├── tsconfig.client.json  # TypeScript config for browser bundle
├── public/
│   ├── index.html   # Single-page UI
│   ├── style.css    # Styles
│   ├── app.ts       # Browser-side logic (TypeScript source)
│   └── app.js       # Compiled browser bundle (generated by tsc)
├── tests/
│   ├── server.test.ts  # API integration tests
│   ├── db.test.ts      # Data-access layer unit tests
│   └── app.test.ts     # Frontend DOM tests
├── DESIGN.md        # This file
└── .gitignore
```

## Running Locally

```bash
npm install   # install dependencies (first time only)
npm start     # start the server on http://localhost:3000
```

## Deploying to a Live Server

The app is a standard Node.js HTTP server. It can be deployed to any platform that supports Node.js, for example:

| Platform | Command |
|----------|---------|
| [Railway](https://railway.app) | Push to GitHub, connect repo |
| [Render](https://render.com) | Push to GitHub, connect repo |
| [Heroku](https://heroku.com) | `git push heroku main` |
| Any VPS | `ts-node server.ts` (behind nginx or similar) |

The `PORT` environment variable is respected (`process.env.PORT || 3000`), which is the convention expected by all major hosting providers.
